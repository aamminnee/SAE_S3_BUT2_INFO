explication générale : 
.
├── code
│   ├── dependance
│   └── exec
├── input
└── output

PS : dossier exemple non représenter (exemple contient la sortie attendu des fichier pour limag1.txt)

j'ai organisés mon projet a l'aide de 6 dossiers (voir en haut) : 

code : contient les fichiers.c 
dependance : contient les fichiers.haut
exec : contient les fichiers.o lors de la compilation et l'éxécutable pavage
input : les fichiers.txt d'entrée pour l'algorithme
output : les fihcier.txt de sortie pour l'algorithme

j'ai des fichiers solution_XXX qui intègrent des algorithmes différents :

solution.c : pas de pavage mais possède les fonction commune pour les autres fichiers
solution_1x1.c : pavage avec les briques 1x1 
solution_greedy_1x2.c : pavage avec les briques 2x1, 1x1 (méthode gloutonne)
solution_greedy_1x2_stock.c : pavage avec les briques 2x1, 1x1 (méthode gloutonne) + gestion du stock (changemen tde forme et couleur)
solution_2x2.c  : pavage avec les briques 4x2, 2x2, 2x1, 1x1
solution_rectfusion.c : pavage avec les briques 4x2, 3x2, 2x2, 2x1, 1x1
solution_forme_arbitraire_rentable.c  : pavage avec les briques 4x2, 3x2, 2x2, 2x1, 1x1 + algo rentabilité


explication détaillé de la version 3: 

solution_1x1.c : partie 1
solution_greedy_1x2 : partie 2
solution.c : a partie

solution_greedy_1x2_stock : 

L’algorithme commence par construire une solution en briques 1x1 pour connaître la couleur la plus adaptée à chaque pixel. 
Ensuite, il initialise une structure de matching qui tentera d’associer des paires de pixels afin de placer des briques 1x2. 
Pour chaque pixel, il essaie de former une paire avec un voisin horizontal ou vertical ayant la même couleur idéale. 
Si le voisin est libre, la paire est créée. S’il est déjà associé, l’algorithme essaie de libérer sa place pour permettre la création de la nouvelle paire.

Une fois le matching terminé, l’algorithme parcourt tous les pixels. 
Les pixels non associés reçoivent une brique 1x1 correspondant au mieux à leur couleur et dans la limite du stock disponible. 
Les pixels associés deux par deux reçoivent une brique 1x2 si une brique correspondante est disponible en stock. 
Si ce n’est pas possible, un choix alternatif de brique 2x1 est tenté. Si aucune brique 2x1 n’est utilisable, 
les deux pixels concernés reçoivent chacun une brique 1x1.

Le stock des briques utilisées est mis à jour et la solution finale est retournée.


solution_2x2.c  : 

L’algorithme commence par calculer pour chaque pixel la couleur de brique 1×1 la plus proche. À partir de ces couleurs, il repère les zones 2×2 où les quatre pixels ont la même couleur estimée.
Chaque carré homogène devient un nœud candidat pour une brique 2×2. Ensuite, il tente de regrouper deux carrés 2×2 alignés horizontalement pour former un rectangle utilisable en 4×2. 
Lorsqu’une paire est trouvée et qu’une brique 4×2 de la bonne couleur existe, elle est placée. Sinon, chaque carré 2×2 est couvert soit par une brique 2×2, 
soit par quatre briques 1×1 si aucune brique 2×2 n’est disponible.

Une fois les grandes zones posées, l’algorithme traite les pixels restants. 
Il cherche à regrouper deux pixels adjacents de même couleur pour utiliser une brique 2×1. 
Si c’est possible et qu’elle existe, la brique 2×1 est utilisée. 
Si ce n’est pas possible, chaque pixel restant est couvert par une brique 1×1 correspondant à la couleur la plus proche. 
L’algorithme termine en mettant à jour le stock utilisé et renvoie la solution complète.


solution_rectfusion.c :

l’algorithme calcule la couleur 1×1 de référence par pixel, déduit la liste des formes rectangulaires disponibles et les trie par surface (puis largeur). 
Il parcourt la grille et, pour chaque position non couverte, tente de poser la plus grande forme rectangulaire (avec rotation) qui tient dans l’image, 
recouvre une zone non couverte et dont tous les pixels ont la même couleur de référence ; il pose la brique correspondante si disponible, 
sinon une brique quelconque de cette forme, et en dernier recours pose une brique 1×1. Le placement est exclusivement glouton et met à jour le stock avant de retourner la solution.


solution_forme_arbitraire_rentable.c  : 

L’algorithme calcule la "rentabilité" de chaque brique (prix/surface), trie les briques décroissantes par rentabilité et, pour les briques de surface supérieure au seuil, 
essaie de poser partout où le rectangle correspondant est libre et où la couleur de la brique correspond exactement aux pixels (erreur nulle). 
Après cette phase il comble les pixels restants en choisissant la brique 1×1 la plus proche en couleur.